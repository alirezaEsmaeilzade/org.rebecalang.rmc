\#include "OrderSpec.h"

#foreach($instance in $mailboxDeclaration)
    #set($counter = 1)
    #foreach($expression in $instance.getOrders())
        #if ($expression.getClass().getSimpleName() == "BinaryExpression" || $expression.getClass().getSimpleName() == "UnaryExpression")
${instance.getName()}OrderSpec${counter}::${instance.getName()}OrderSpec${counter}() {}

OrderCommand ${instance.getName()}OrderSpec${counter}::order(int queueTail, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
    if (($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "queueTail")) && !($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "queueTail - 1")))
        return OrderCommand::Swap;
    if (!($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "queueTail")) && ($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "queueTail - 1")))
        return OrderCommand::NoSwap;
    else
        return OrderCommand::Skip;
}

bool ${instance.getName()}OrderSpec${counter}::checkOrder(int a, int b, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
    return ($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "a")) && ($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "b")) ||
        !($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "a")) && !($mailBoxBodyConvertor.ConvertConditionalOrderSpec($expression, "b"));
}

            #set($counter = $counter + 1)
        #end
    #end
#end

## TODO: should generated by above code after compiler complitly support message name.
MessageNameOrderSpec::MessageNameOrderSpec(int special) : specialMessage(special) {}

OrderCommand MessageNameOrderSpec::order(int queueTail, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
    if (messageQueue[queueTail] == specialMessage && messageQueue[queueTail - 1] != specialMessage)
        return OrderCommand::Swap;
    if (messageQueue[queueTail] != specialMessage && messageQueue[queueTail - 1] == specialMessage)
        return OrderCommand::NoSwap;
    else
        return OrderCommand::Skip;
}

bool MessageNameOrderSpec::checkOrder(int a, int b, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
    return messageQueue[a] == specialMessage && messageQueue[b] == specialMessage ||
        messageQueue[a] != specialMessage && messageQueue[b] != specialMessage;
}

DeadlineOrderSpec::DeadlineOrderSpec(bool isMin) : isMin(isMin) {}

OrderCommand DeadlineOrderSpec::order(int queueTail, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
    if ((int)deadline[queueTail] == (int)deadline[queueTail - 1])
        return OrderCommand::Skip;
    if (isMin ? (int)deadline[queueTail] < (int)deadline[queueTail - 1] : (int)deadline[queueTail] > (int)deadline[queueTail - 1])
        return OrderCommand::Swap;

    return OrderCommand::NoSwap;
}

bool DeadlineOrderSpec::checkOrder(int a, int b, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
        return deadline[a] == deadline[b];
    }

DelayOrderSpec::DelayOrderSpec(bool isMin) : isMin(isMin) {}

OrderCommand DelayOrderSpec::order(int queueTail, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
    if (delay[queueTail] == delay[queueTail - 1])
        return OrderCommand::Skip;
    if (isMin ? delay[queueTail] < delay[queueTail - 1] : delay[queueTail] > delay[queueTail - 1])
        return OrderCommand::Swap;

    return OrderCommand::NoSwap;
}

bool DelayOrderSpec::checkOrder(int a, int b, TIME_TYPE *executionTime, TIME_TYPE *deadline, byte *messageQueue, byte *senderQueue, TIME_TYPE *delay, const vector<AbstractActor *> &rebecs) {
    return delay[a] == delay[b];
}